# Tim's Stack: Dynamic cross plattform web app stack


## Stack Components

- nextjs + react frontend (deployment)
    - tailwind + dasyui 
    - automatic plattform adjustments for api calls, authentication and native functions (my custom implementation)
    - global redis store + auto background update websocket
    - capacitor setup for native integrations and ios / android pwa export

- django backend (deployment)
    - celery for tasks management ( or for offloading time intensive tasks )
    - rest_framework + django_rest_dataclasses for rapid REST api development
    - django proxy for authenticating views on other pods like the docs
    - drf_spectacular for autogenerated api documentation
    - django channels for managing websockets and sending update to clinets

- documentation (deployment)
    - pdoc3 code documentation generated from backend code
    
- postgresql (helm chart)
    - main backend database

- redis (helm chart)
    - broker for celery
    - db for django channels
    
## Usage
    
### Local Development
    
For full local development you have the choice between running the full stack withing `microk8s` locally, or using `docker` and the `Makefile` to run individual components.

#### Microk8s local development

> This is harder to debug but allowes testing microservice interactions

This will spinup the stack configured for local development (`helm/values.yaml`), this is configured to mount directoryies `back/` and `front/` directly into the respecive containers to you will have hot code reloading!

1. setup `microk8s`: `make microk8s_setup`
2. build images and push them to the local microk8s registry: `make full_build_deploy`
3. Install the helm chart: `make helm_install` ( or use `make helm_update` to update an existing chart installation)

> You can switch micrk8s off when your finished with development `microk8s stop`

#### Docker local development

> This is the simples way to develop and debug, but has some differences in local routing strategies